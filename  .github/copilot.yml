# .github/copilot.yml
version: 1
rules:
  - name: clean-code-javascript-complete
    description: "严格遵循 ryanmcdermott/clean-code-javascript 完整规范，包含正反例约束"
    enabled: true
    prompts:
      # 变量规则（含正反例）
      - "变量命名：必须有意义、可读性强 | 反例：var yyyymmdstr = moment().format('YYYY/MM/DD'); | 正例：const yearMonthDay = moment().format('YYYY/MM/DD');"
      - "常量定义：用 ES6 const 声明（不可变），全大写命名 | 反例：var FIRST_US_PRESIDENT = 'George Washington'; | 正例：const FIRST_US_PRESIDENT = 'George Washington';"
      - "命名统一：功能类似的变量/函数用相同前缀 | 反例：getUserInfo(); getClientData(); getCustomerRecord(); | 正例：getUser(); getClient(); getCustomer();"
      - "易于检索：魔法数值用常量命名 | 反例：for (let i = 0; i < 525600; i++) { runCronJob(); } | 正例：const MINUTES_IN_A_YEAR = 525600; for (let i = 0; i < MINUTES_IN_A_YEAR; i++) { runCronJob(); }"
      - "说明变量：拆分复杂逻辑，用变量名解释含义 | 反例：saveCityState(regex.match(str)[1], regex.match(str)[2]); | 正例：const match = regex.match(str); const city = match[1]; const state = match[2]; saveCityState(city, state);"
      - "显式命名：循环/回调参数不用缩写 | 反例：locations.forEach((l) => { dispatch(l); }); | 正例：locations.forEach((location) => { dispatch(location); });"
      - "避免冗余：对象属性不重复类名 | 反例：const Car = { carMake: 'Honda', carColor: 'Blue' }; | 正例：const Car = { make: 'Honda', color: 'Blue' };"
      - "条件简化：用默认值替代无意义 if-else | 反例：let breweryName; if (name) { breweryName = name; } else { breweryName = 'Hipster Brew Co.'; } | 正例：const breweryName = name || 'Hipster Brew Co.';"

      # 函数规则（含正反例）
      - "参数限制：最多 2 个参数，多参数封装为对象 | 反例：function createMenu(title, body, buttonText, cancellable) { ... } | 正例：const menuConfig = { title: 'Foo', body: 'Bar' }; function createMenu(menuConfig) { ... }"
      - "单一职责：函数仅做一件事，复杂逻辑拆分 | 反例：function emailClients(clients) { clients.forEach(client => { const record = db.lookup(client); if (record.isActive()) { email(client); } }); } | 正例：function emailClients(clients) { clients.forEach(client => emailClientIfNeeded(client)); } function emailClientIfNeeded(client) { if (isClientActive(client)) { email(client); } }"
      - "命名明确：函数名直接体现功能 | 反例：function dateAdd(date, month) { ... } dateAdd(date, 1); | 正例：function dateAddMonth(date, month) { ... } dateAddMonth(date, 1);"
      - "一层抽象：函数不嵌套多层逻辑 | 反例：function parseCode(code) { // 同时做 tokenize、lex、parse } | 正例：function parseCode(code) { const tokens = tokenize(code); const ast = lexer(tokens); return parseAst(ast); }"
      - "移除重复：合并重复代码 | 反例：showDeveloperList(developers) { ... } showManagerList(managers) { ... } | 正例：showList(employees) { // 用条件判断差异化逻辑 }"
      - "默认参数：用 ES6 默认值替代 || 赋值 | 反例：function writeComment(subject, body) { subject = subject || 'No Subject'; } | 正例：function writeComment(subject = 'No Subject', body = 'No text') { ... }"
      - "对象默认值：用 Object.assign 合并配置 | 反例：config.title = config.title || 'Foo'; config.body = config.body || 'Bar'; | 正例：config = Object.assign({ title: 'Foo', body: 'Bar' }, config);"
      - "禁止 Flag 参数：不⽤布尔值控制逻辑，拆分为独立函数 | 反例：function createFile(name, temp) { if (temp) { fs.create('./temp/' + name); } else { fs.create(name); } } | 正例：function createTempFile(name) { fs.create('./temp/' + name); } function createFile(name) { fs.create(name); }"
      - "避免副作用：不修改全局变量/外部状态 | 反例：let name = 'Ryan'; function splitName() { name = name.split(' '); } | 正例：function splitName(name) { return name.split(' '); } const newName = splitName('Ryan');"
      - "禁止全局函数：不扩展原生原型 | 反例：Array.prototype.diff = function(arr) { ... } | 正例：class SuperArray extends Array { diff(arr) { ... } }"
      - "函数式编程：用 map/reduce/filter 替代 for 循环 | 反例：let total = 0; for (let i = 0; i < list.length; i++) { total += list[i].value; } | 正例：const total = list.map(item => item.value).reduce((acc, val) => acc + val, 0);"
      - "封装判断条件：复杂条件抽为函数 | 反例：if (fsm.state === 'fetching' && isEmpty(listNode)) { ... } | 正例：if (shouldShowSpinner(fsm, listNode)) { ... } function shouldShowSpinner(fsm, listNode) { return fsm.state === 'fetching' && isEmpty(listNode); }"
      - "避免否定判断：函数名用肯定式 | 反例：function isDOMNodeNotPresent(node) { ... } if (!isDOMNodeNotPresent(node)) { ... } | 正例：function isDOMNodePresent(node) { ... } if (isDOMNodePresent(node)) { ... }"
      - "避免条件判断：用多态替代 switch | 反例：class Airplane { getCruisingAltitude() { switch (this.type) { case '777': ...; case 'Cessna': ...; } } } | 正例：class Boeing777 extends Airplane { getCruisingAltitude() { ... } } class Cessna extends Airplane { getCruisingAltitude() { ... } }"
      - "避免类型判断：用统一接口替代 instanceof | 反例：function travel(vehicle) { if (vehicle instanceof Bicycle) { vehicle.pedal(); } else if (vehicle instanceof Car) { vehicle.drive(); } } | 正例：function travel(vehicle) { vehicle.move(); }"
      - "不过度优化：不做浏览器兼容冗余优化 | 反例：for (let i = 0, len = list.length; i < len; i++) { ... } | 正例：for (let i = 0; i < list.length; i++) { ... }"
      - "删除无效代码：不保留未被调用的函数/变量 | 反例：function oldFunc() { ... } function newFunc() { ... } const req = newFunc(); | 正例：function newFunc() { ... } const req = newFunc();"

      # 对象和数据结构（含正反例）
      - "使用 getters/setters：封装属性操作 | 反例：class BankAccount { constructor() { this.balance = 1000; } } bankAccount.balance -= 100; | 正例：class BankAccount { withdraw(amount) { if (amount <= this.balance) { this.balance -= amount; } } } bankAccount.withdraw(100);"
      - "私有成员：通过闭包隐藏私有属性 | 反例：var Employee = function(name) { this.name = name; } const emp = new Employee('John'); delete emp.name; | 正例：var Employee = (function() { return function(name) { this.getName = function() { return name; }; }; })(); const emp = new Employee('John'); delete emp.name; // 无效"

      # 类规则（含正反例）
      - "单一职责原则：类仅负责一项功能 | 反例：class UserSettings { constructor(user) { this.user = user; } changeSettings() { if (this.verifyCredentials()) { ... } } verifyCredentials() { ... } } | 正例：class UserAuth { verifyCredentials(user) { ... } } class UserSettings { constructor(user) { this.auth = new UserAuth(user); } changeSettings() { if (this.auth.verifyCredentials()) { ... } } }"
      - "开闭原则：易于扩展、难于修改 | 反例：class AjaxRequester { constructor() { this.HTTP_METHODS = ['POST', 'PUT', 'GET']; } } | 正例：class AjaxRequester { constructor() { this.HTTP_METHODS = ['POST', 'PUT', 'GET']; } addHTTPMethod(method) { this.HTTP_METHODS.push(method); } }"
      - "利斯科夫替代原则：子类可替换父类 | 反例：class Square extends Rectangle { setWidth(w) { this.width = w; this.height = w; } } function renderRect(rect) { rect.setWidth(4); rect.setHeight(5); console.log(rect.getArea()); // 正方形返回 25（错误） } | 正例：class Shape { ... } class Rectangle extends Shape { ... } class Square extends Shape { ... } function renderShape(shape) { ... }"
      - "接口隔离原则：依赖最小接口 | 反例：class DOMTraverser { constructor(settings) { this.rootNode = settings.rootNode; this.animationModule = settings.animationModule; } } | 正例：class DOMTraverser { constructor(settings) { this.rootNode = settings.rootNode; this.options = settings.options; } setup() { if (this.options.animationModule) { ... } } }"
      - "依赖反转原则：依赖抽象而非实现 | 反例：class InventoryTracker { constructor(items) { this.requester = new InventoryRequester(); } } | 正例：class InventoryTracker { constructor(items, requester) { this.requester = requester; } } const tracker = new InventoryTracker(items, new InventoryRequesterV2());"
      - "ES6 Class：用 class 替代 ES5 构造函数 | 反例：var Mammal = function(age) { Animal.call(this, age); } Mammal.prototype = Object.create(Animal.prototype); | 正例：class Mammal extends Animal { constructor(age) { super(age); } }"
      - "方法链：方法返回 this 支持链式调用 | 反例：class Car { setColor(c) { this.color = c; } setMake(m) { this.make = m; } } const car = new Car(); car.setColor('red'); car.setMake('Ford'); | 正例：class Car { setColor(c) { this.color = c; return this; } setMake(m) { this.make = m; return this; } } const car = new Car().setColor('red').setMake('Ford');"
      - "优先组合而非继承：「有一个」用组合，「是一个」用继承 | 反例：class EmployeeTaxData extends Employee { ... } // TaxData 是 Employee 的「有」，不是「是」 | 正例：class EmployeeTaxData { ... } class Employee { constructor() { this.taxData = new EmployeeTaxData(); } }"

      # 测试规则（含正反例）
      - "单一测试：每个用例仅测试一个概念 | 反例：it('handles date boundaries', function() { // 同时测试 30天月、闰年、非闰年 }); | 正例：it('handles 30-day months', function() { ... }); it('handles leap year', function() { ... }); it('handles non-leap year', function() { ... });"

      # 并发规则（含正反例）
      - "Promise 替代回调：不用嵌套回调 | 反例：request.get(url, function(err, res) { if (!err) { fs.writeFile('file.html', res.body, function(err) { ... }); } }); | 正例：requestPromise.get(url).then(res => fsPromise.writeFile('file.html', res.body)).then(() => console.log('done')).catch(err => console.error(err));"
      - "async/await 优先：替代 Promise 链 | 反例：requestPromise.get(url).then(res => fsPromise.writeFile('file.html', res.body)).then(() => console.log('done')).catch(err => console.error(err)); | 正例：async function fetchAndSave() { try { const res = await requestPromise.get(url); await fsPromise.writeFile('file.html', res.body); console.log('done'); } catch (err) { console.error(err); } }"

      # 错误处理规则（含正反例）
      - "捕获必处理：catch 中不忽略错误 | 反例：try { functionThatMightThrow(); } catch (err) { console.log(err); } | 正例：try { functionThatMightThrow(); } catch (err) { console.error(err); notifyUser(err); reportError(err); }"
      - "不忽略 Promise 拒绝：catch 必须处理 | 反例：fetchData().then(data => process(data)).catch(err => console.log(err)); | 正例：fetchData().then(data => process(data)).catch(err => { console.error(err); notifyUser('加载失败'); })"

      # 格式化规则（含正反例）
      - "大小写一致：统一命名风格 | 反例：const DAYS_IN_WEEK = 7; const daysInMonth = 30; function eraseDatabase() {} function restore_database() {} | 正例：const DAYS_IN_WEEK = 7; const DAYS_IN_MONTH = 30; function eraseDatabase() {} function restoreDatabase() {}"
      - "函数位置：调用者与被调用者相近 | 反例：class PerformanceReview { lookupPeers() { ... } getPeerReviews() { ... } perfReview() { getPeerReviews(); } } | 正例：class PerformanceReview { perfReview() { getPeerReviews(); } getPeerReviews() { ... } lookupPeers() { ... } }"

      # 注释规则（含正反例）
      - "仅注释复杂逻辑：不写冗余注释 | 反例：function hashIt(data) { // 初始化 hash var hash = 0; // 循环每个字符 for (let i = 0; i < data.length; i++) { ... } } | 正例：function hashIt(data) { let hash = 0; for (let i = 0; i < data.length; i++) { ... } // 转换为 32-bit 整数 hash = hash & hash; }"
      - "删除注释代码：不保留无用代码 | 反例：doStuff(); // doOtherStuff(); // doSomeMoreStuff(); | 正例：doStuff();"
      - "无版本注释：不用注释记录更新历史 | 反例：/** 2025-01-01: 修复 bug（XX） */ function combine(a, b) { ... } | 正例：function combine(a, b) { ... } // 用 git log 查看历史"
      - "无位置标记：不用分割线注释 | 反例：//////////////////////////////////////////////////////////////////////////////// // 变量定义 //////////////////////////////////////////////////////////////////////////////// const x = 1; | 正例：const x = 1;"
      - "无法律注释：不嵌入 LICENSE 文本 | 反例：/* The MIT License (MIT) Copyright (c) 2025 ... */ function calculate() { ... } | 正例：function calculate() { ... } // LICENSE 放在项目根目录"

      # 一个文件不能超过300行
      - "文件长度限制：单个文件不超过 300 行，最好在150行左右 | 反例：// 文件超过 300 行 | 正例：// 将文件拆分为多个模块"

      # 一个html/jsx文件不能超过35行
      - "HTML/JSX 文件长度限制：单个 HTML/JSX 文件不超过 35 行 | 反例：// HTML/JSX 文件超过 35 行 | 正例：// 将组件拆分为更小的子组件"
